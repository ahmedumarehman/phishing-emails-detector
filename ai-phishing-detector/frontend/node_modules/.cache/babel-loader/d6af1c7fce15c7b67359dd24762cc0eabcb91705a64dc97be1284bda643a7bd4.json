{"ast":null,"code":"// Mock API service for frontend-only application\n// This replaces the backend API calls with simulated responses\n\n// Phishing keywords and patterns for detection\nconst phishingKeywords = ['urgent', 'verify', 'suspend', 'click here', 'act now', 'limited time', 'verify account', 'update payment', 'confirm identity', 'security alert', 'login required', 'account locked', 'unusual activity', 'verify now', 'immediate action', 'expire', 'unauthorized access', 'security breach'];\nconst phishingDomains = ['bit.ly', 'tinyurl.com', 'goo.gl', 't.co', 'ow.ly', 'is.gd', 'suspicious-link.com', 'fake-bank.net', 'phishing-site.org'];\nconst suspiciousPatterns = [/\\b[A-Z]{2,}\\s+[A-Z]{2,}/g,\n// Multiple uppercase words\n/\\$\\d+/g,\n// Money amounts\n/click\\s+here/gi, /verify\\s+now/gi, /urgent/gi, /act\\s+now/gi, /limited\\s+time/gi];\n\n// URL regex pattern\nconst urlPattern = /(https?:\\/\\/[^\\s]+)/gi;\n\n// Simulate AI analysis delay\nconst simulateDelay = (ms = 1500) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Extract URLs from text\nconst extractUrls = text => {\n  const urls = text.match(urlPattern) || [];\n  return urls;\n};\n\n// Analyze email content for phishing indicators\nconst analyzeEmailContent = (subject, body) => {\n  const fullText = `${subject} ${body}`.toLowerCase();\n  let phishingScore = 0;\n  let suspiciousElements = [];\n\n  // Check for phishing keywords\n  phishingKeywords.forEach(keyword => {\n    if (fullText.includes(keyword.toLowerCase())) {\n      phishingScore += 15;\n      suspiciousElements.push(keyword);\n    }\n  });\n\n  // Check for suspicious patterns\n  suspiciousPatterns.forEach(pattern => {\n    const matches = fullText.match(pattern);\n    if (matches) {\n      phishingScore += matches.length * 10;\n      suspiciousElements.push(...matches);\n    }\n  });\n\n  // Check URLs\n  const urls = extractUrls(body);\n  const maliciousUrls = [];\n  urls.forEach(url => {\n    phishingDomains.forEach(domain => {\n      if (url.includes(domain)) {\n        phishingScore += 25;\n        maliciousUrls.push(url);\n      }\n    });\n\n    // Check for suspicious URL characteristics\n    if (url.length > 50) phishingScore += 5;\n    if (url.includes('bit.ly') || url.includes('tinyurl')) phishingScore += 10;\n    if ((url.match(/\\./g) || []).length > 3) phishingScore += 5;\n  });\n\n  // Additional heuristics\n  if (subject.includes('!')) phishingScore += 5;\n  if (fullText.includes('congratulations')) phishingScore += 10;\n  if (fullText.includes('winner') || fullText.includes('won')) phishingScore += 15;\n\n  // Cap the score at 100\n  phishingScore = Math.min(phishingScore, 100);\n  return {\n    score: phishingScore,\n    suspiciousElements,\n    urls,\n    maliciousUrls\n  };\n};\n\n// Mock email API\nexport const emailAPI = {\n  predictPhishing: async emailData => {\n    await simulateDelay();\n    const {\n      subject,\n      body\n    } = emailData;\n    const analysis = analyzeEmailContent(subject, body);\n    const isPhishing = analysis.score > 50;\n    const confidence = Math.min(95, Math.max(60, analysis.score + Math.random() * 20));\n\n    // Generate URL predictions\n    const urlPredictions = analysis.urls.map(url => {\n      const isUrlPhishing = analysis.maliciousUrls.includes(url) || Math.random() > 0.7;\n      return {\n        url,\n        prediction: isUrlPhishing ? 'Phishing' : 'Safe',\n        confidence: isUrlPhishing ? Math.random() * 30 + 70 : Math.random() * 30 + 50\n      };\n    });\n    return {\n      prediction: isPhishing ? 'Phishing Email' : 'Safe Email',\n      confidence: Math.round(confidence),\n      reason: isPhishing ? 'Multiple phishing indicators detected' : 'No significant phishing patterns found',\n      analysis_type: 'Frontend Heuristic Analysis',\n      total_links: analysis.urls.length,\n      malicious_links: analysis.maliciousUrls,\n      suspicious_patterns: [...new Set(analysis.suspiciousElements)],\n      url_predictions: urlPredictions\n    };\n  },\n  batchPredict: async emailsData => {\n    await simulateDelay(2000);\n    const results = [];\n    for (const email of emailsData.emails) {\n      const result = await emailAPI.predictPhishing(email);\n      results.push(result);\n    }\n    return {\n      results\n    };\n  },\n  healthCheck: async () => {\n    await simulateDelay(500);\n    return {\n      status: 'healthy',\n      models_loaded: true,\n      message: 'Frontend-only mode - using heuristic analysis',\n      version: '2.0.0-frontend'\n    };\n  }\n};\n\n// Mock URL analysis\nexport const urlAPI = {\n  predictURL: async urlData => {\n    var _url$split$;\n    await simulateDelay(1200);\n    const {\n      url\n    } = urlData;\n    let phishingScore = 0;\n    const features = {};\n\n    // Basic URL analysis\n    features.url_length = url.length;\n    features.domain_length = ((_url$split$ = url.split('/')[2]) === null || _url$split$ === void 0 ? void 0 : _url$split$.length) || 0;\n    features.path_length = url.split('/').slice(3).join('/').length;\n    features.dots_count = (url.match(/\\./g) || []).length;\n    features.hyphens_count = (url.match(/-/g) || []).length;\n    features.underscores_count = (url.match(/_/g) || []).length;\n    features.slashes_count = (url.match(/\\//g) || []).length;\n    features.question_marks_count = (url.match(/\\?/g) || []).length;\n    features.equals_count = (url.match(/=/g) || []).length;\n    features.at_count = (url.match(/@/g) || []).length;\n\n    // Scoring logic\n    if (features.url_length > 75) phishingScore += 20;\n    if (features.dots_count > 3) phishingScore += 15;\n    if (features.hyphens_count > 2) phishingScore += 10;\n    if (url.includes('bit.ly') || url.includes('tinyurl')) phishingScore += 30;\n    if (phishingDomains.some(domain => url.includes(domain))) phishingScore += 40;\n\n    // Add some randomness for demo purposes\n    phishingScore += Math.random() * 20;\n    phishingScore = Math.min(100, phishingScore);\n    const isPhishing = phishingScore > 60;\n    const confidence = Math.min(95, Math.max(65, phishingScore + Math.random() * 15));\n    return {\n      prediction: isPhishing ? 'Phishing' : 'Safe',\n      confidence: Math.round(confidence),\n      features,\n      analysis_method: 'Heuristic URL Analysis',\n      risk_factors: isPhishing ? ['Suspicious domain', 'Unusual URL structure', 'High character count'] : []\n    };\n  },\n  trainEnhancedModel: async () => {\n    await simulateDelay(3000);\n    return {\n      status: 'success',\n      message: 'Model training simulation completed',\n      accuracy: 0.92 + Math.random() * 0.05,\n      training_time: '45 seconds'\n    };\n  }\n};\nconst mockAPI = {\n  emailAPI,\n  urlAPI\n};\nexport default mockAPI;","map":{"version":3,"names":["phishingKeywords","phishingDomains","suspiciousPatterns","urlPattern","simulateDelay","ms","Promise","resolve","setTimeout","extractUrls","text","urls","match","analyzeEmailContent","subject","body","fullText","toLowerCase","phishingScore","suspiciousElements","forEach","keyword","includes","push","pattern","matches","length","maliciousUrls","url","domain","Math","min","score","emailAPI","predictPhishing","emailData","analysis","isPhishing","confidence","max","random","urlPredictions","map","isUrlPhishing","prediction","round","reason","analysis_type","total_links","malicious_links","suspicious_patterns","Set","url_predictions","batchPredict","emailsData","results","email","emails","result","healthCheck","status","models_loaded","message","version","urlAPI","predictURL","urlData","_url$split$","features","url_length","domain_length","split","path_length","slice","join","dots_count","hyphens_count","underscores_count","slashes_count","question_marks_count","equals_count","at_count","some","analysis_method","risk_factors","trainEnhancedModel","accuracy","training_time","mockAPI"],"sources":["D:/DATA/CAREER/INTERNSHIPS/EMRChains Internship NSTP/PROJECTS/phishing-emails - Copy/ai-phishing-detector/frontend/src/mockAPI.js"],"sourcesContent":["// Mock API service for frontend-only application\r\n// This replaces the backend API calls with simulated responses\r\n\r\n// Phishing keywords and patterns for detection\r\nconst phishingKeywords = [\r\n    'urgent', 'verify', 'suspend', 'click here', 'act now', 'limited time',\r\n    'verify account', 'update payment', 'confirm identity', 'security alert',\r\n    'login required', 'account locked', 'unusual activity', 'verify now',\r\n    'immediate action', 'expire', 'unauthorized access', 'security breach'\r\n];\r\n\r\nconst phishingDomains = [\r\n    'bit.ly', 'tinyurl.com', 'goo.gl', 't.co', 'ow.ly', 'is.gd',\r\n    'suspicious-link.com', 'fake-bank.net', 'phishing-site.org'\r\n];\r\n\r\nconst suspiciousPatterns = [\r\n    /\\b[A-Z]{2,}\\s+[A-Z]{2,}/g, // Multiple uppercase words\r\n    /\\$\\d+/g, // Money amounts\r\n    /click\\s+here/gi,\r\n    /verify\\s+now/gi,\r\n    /urgent/gi,\r\n    /act\\s+now/gi,\r\n    /limited\\s+time/gi\r\n];\r\n\r\n// URL regex pattern\r\nconst urlPattern = /(https?:\\/\\/[^\\s]+)/gi;\r\n\r\n// Simulate AI analysis delay\r\nconst simulateDelay = (ms = 1500) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// Extract URLs from text\r\nconst extractUrls = (text) => {\r\n    const urls = text.match(urlPattern) || [];\r\n    return urls;\r\n};\r\n\r\n// Analyze email content for phishing indicators\r\nconst analyzeEmailContent = (subject, body) => {\r\n    const fullText = `${subject} ${body}`.toLowerCase();\r\n    let phishingScore = 0;\r\n    let suspiciousElements = [];\r\n\r\n    // Check for phishing keywords\r\n    phishingKeywords.forEach(keyword => {\r\n        if (fullText.includes(keyword.toLowerCase())) {\r\n            phishingScore += 15;\r\n            suspiciousElements.push(keyword);\r\n        }\r\n    });\r\n\r\n    // Check for suspicious patterns\r\n    suspiciousPatterns.forEach(pattern => {\r\n        const matches = fullText.match(pattern);\r\n        if (matches) {\r\n            phishingScore += matches.length * 10;\r\n            suspiciousElements.push(...matches);\r\n        }\r\n    });\r\n\r\n    // Check URLs\r\n    const urls = extractUrls(body);\r\n    const maliciousUrls = [];\r\n\r\n    urls.forEach(url => {\r\n        phishingDomains.forEach(domain => {\r\n            if (url.includes(domain)) {\r\n                phishingScore += 25;\r\n                maliciousUrls.push(url);\r\n            }\r\n        });\r\n\r\n        // Check for suspicious URL characteristics\r\n        if (url.length > 50) phishingScore += 5;\r\n        if (url.includes('bit.ly') || url.includes('tinyurl')) phishingScore += 10;\r\n        if ((url.match(/\\./g) || []).length > 3) phishingScore += 5;\r\n    });\r\n\r\n    // Additional heuristics\r\n    if (subject.includes('!')) phishingScore += 5;\r\n    if (fullText.includes('congratulations')) phishingScore += 10;\r\n    if (fullText.includes('winner') || fullText.includes('won')) phishingScore += 15;\r\n\r\n    // Cap the score at 100\r\n    phishingScore = Math.min(phishingScore, 100);\r\n\r\n    return {\r\n        score: phishingScore,\r\n        suspiciousElements,\r\n        urls,\r\n        maliciousUrls\r\n    };\r\n};\r\n\r\n// Mock email API\r\nexport const emailAPI = {\r\n    predictPhishing: async (emailData) => {\r\n        await simulateDelay();\r\n\r\n        const { subject, body } = emailData;\r\n        const analysis = analyzeEmailContent(subject, body);\r\n\r\n        const isPhishing = analysis.score > 50;\r\n        const confidence = Math.min(95, Math.max(60, analysis.score + Math.random() * 20));\r\n\r\n        // Generate URL predictions\r\n        const urlPredictions = analysis.urls.map(url => {\r\n            const isUrlPhishing = analysis.maliciousUrls.includes(url) || Math.random() > 0.7;\r\n            return {\r\n                url,\r\n                prediction: isUrlPhishing ? 'Phishing' : 'Safe',\r\n                confidence: isUrlPhishing ?\r\n                    Math.random() * 30 + 70 :\r\n                    Math.random() * 30 + 50\r\n            };\r\n        });\r\n\r\n        return {\r\n            prediction: isPhishing ? 'Phishing Email' : 'Safe Email',\r\n            confidence: Math.round(confidence),\r\n            reason: isPhishing ?\r\n                'Multiple phishing indicators detected' :\r\n                'No significant phishing patterns found',\r\n            analysis_type: 'Frontend Heuristic Analysis',\r\n            total_links: analysis.urls.length,\r\n            malicious_links: analysis.maliciousUrls,\r\n            suspicious_patterns: [...new Set(analysis.suspiciousElements)],\r\n            url_predictions: urlPredictions\r\n        };\r\n    },\r\n\r\n    batchPredict: async (emailsData) => {\r\n        await simulateDelay(2000);\r\n\r\n        const results = [];\r\n        for (const email of emailsData.emails) {\r\n            const result = await emailAPI.predictPhishing(email);\r\n            results.push(result);\r\n        }\r\n\r\n        return { results };\r\n    },\r\n\r\n    healthCheck: async () => {\r\n        await simulateDelay(500);\r\n\r\n        return {\r\n            status: 'healthy',\r\n            models_loaded: true,\r\n            message: 'Frontend-only mode - using heuristic analysis',\r\n            version: '2.0.0-frontend'\r\n        };\r\n    }\r\n};\r\n\r\n// Mock URL analysis\r\nexport const urlAPI = {\r\n    predictURL: async (urlData) => {\r\n        await simulateDelay(1200);\r\n\r\n        const { url } = urlData;\r\n        let phishingScore = 0;\r\n        const features = {};\r\n\r\n        // Basic URL analysis\r\n        features.url_length = url.length;\r\n        features.domain_length = url.split('/')[2]?.length || 0;\r\n        features.path_length = url.split('/').slice(3).join('/').length;\r\n        features.dots_count = (url.match(/\\./g) || []).length;\r\n        features.hyphens_count = (url.match(/-/g) || []).length;\r\n        features.underscores_count = (url.match(/_/g) || []).length;\r\n        features.slashes_count = (url.match(/\\//g) || []).length;\r\n        features.question_marks_count = (url.match(/\\?/g) || []).length;\r\n        features.equals_count = (url.match(/=/g) || []).length;\r\n        features.at_count = (url.match(/@/g) || []).length;\r\n\r\n        // Scoring logic\r\n        if (features.url_length > 75) phishingScore += 20;\r\n        if (features.dots_count > 3) phishingScore += 15;\r\n        if (features.hyphens_count > 2) phishingScore += 10;\r\n        if (url.includes('bit.ly') || url.includes('tinyurl')) phishingScore += 30;\r\n        if (phishingDomains.some(domain => url.includes(domain))) phishingScore += 40;\r\n\r\n        // Add some randomness for demo purposes\r\n        phishingScore += Math.random() * 20;\r\n        phishingScore = Math.min(100, phishingScore);\r\n\r\n        const isPhishing = phishingScore > 60;\r\n        const confidence = Math.min(95, Math.max(65, phishingScore + Math.random() * 15));\r\n\r\n        return {\r\n            prediction: isPhishing ? 'Phishing' : 'Safe',\r\n            confidence: Math.round(confidence),\r\n            features,\r\n            analysis_method: 'Heuristic URL Analysis',\r\n            risk_factors: isPhishing ? [\r\n                'Suspicious domain',\r\n                'Unusual URL structure',\r\n                'High character count'\r\n            ] : []\r\n        };\r\n    },\r\n\r\n    trainEnhancedModel: async () => {\r\n        await simulateDelay(3000);\r\n\r\n        return {\r\n            status: 'success',\r\n            message: 'Model training simulation completed',\r\n            accuracy: 0.92 + Math.random() * 0.05,\r\n            training_time: '45 seconds'\r\n        };\r\n    }\r\n};\r\n\r\nconst mockAPI = { emailAPI, urlAPI };\r\n\r\nexport default mockAPI;\r\n"],"mappings":"AAAA;AACA;;AAEA;AACA,MAAMA,gBAAgB,GAAG,CACrB,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,SAAS,EAAE,cAAc,EACtE,gBAAgB,EAAE,gBAAgB,EAAE,kBAAkB,EAAE,gBAAgB,EACxE,gBAAgB,EAAE,gBAAgB,EAAE,kBAAkB,EAAE,YAAY,EACpE,kBAAkB,EAAE,QAAQ,EAAE,qBAAqB,EAAE,iBAAiB,CACzE;AAED,MAAMC,eAAe,GAAG,CACpB,QAAQ,EAAE,aAAa,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAC3D,qBAAqB,EAAE,eAAe,EAAE,mBAAmB,CAC9D;AAED,MAAMC,kBAAkB,GAAG,CACvB,0BAA0B;AAAE;AAC5B,QAAQ;AAAE;AACV,gBAAgB,EAChB,gBAAgB,EAChB,UAAU,EACV,aAAa,EACb,kBAAkB,CACrB;;AAED;AACA,MAAMC,UAAU,GAAG,uBAAuB;;AAE1C;AACA,MAAMC,aAAa,GAAGA,CAACC,EAAE,GAAG,IAAI,KAAK,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;;AAEpF;AACA,MAAMI,WAAW,GAAIC,IAAI,IAAK;EAC1B,MAAMC,IAAI,GAAGD,IAAI,CAACE,KAAK,CAACT,UAAU,CAAC,IAAI,EAAE;EACzC,OAAOQ,IAAI;AACf,CAAC;;AAED;AACA,MAAME,mBAAmB,GAAGA,CAACC,OAAO,EAAEC,IAAI,KAAK;EAC3C,MAAMC,QAAQ,GAAG,GAAGF,OAAO,IAAIC,IAAI,EAAE,CAACE,WAAW,CAAC,CAAC;EACnD,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,kBAAkB,GAAG,EAAE;;EAE3B;EACAnB,gBAAgB,CAACoB,OAAO,CAACC,OAAO,IAAI;IAChC,IAAIL,QAAQ,CAACM,QAAQ,CAACD,OAAO,CAACJ,WAAW,CAAC,CAAC,CAAC,EAAE;MAC1CC,aAAa,IAAI,EAAE;MACnBC,kBAAkB,CAACI,IAAI,CAACF,OAAO,CAAC;IACpC;EACJ,CAAC,CAAC;;EAEF;EACAnB,kBAAkB,CAACkB,OAAO,CAACI,OAAO,IAAI;IAClC,MAAMC,OAAO,GAAGT,QAAQ,CAACJ,KAAK,CAACY,OAAO,CAAC;IACvC,IAAIC,OAAO,EAAE;MACTP,aAAa,IAAIO,OAAO,CAACC,MAAM,GAAG,EAAE;MACpCP,kBAAkB,CAACI,IAAI,CAAC,GAAGE,OAAO,CAAC;IACvC;EACJ,CAAC,CAAC;;EAEF;EACA,MAAMd,IAAI,GAAGF,WAAW,CAACM,IAAI,CAAC;EAC9B,MAAMY,aAAa,GAAG,EAAE;EAExBhB,IAAI,CAACS,OAAO,CAACQ,GAAG,IAAI;IAChB3B,eAAe,CAACmB,OAAO,CAACS,MAAM,IAAI;MAC9B,IAAID,GAAG,CAACN,QAAQ,CAACO,MAAM,CAAC,EAAE;QACtBX,aAAa,IAAI,EAAE;QACnBS,aAAa,CAACJ,IAAI,CAACK,GAAG,CAAC;MAC3B;IACJ,CAAC,CAAC;;IAEF;IACA,IAAIA,GAAG,CAACF,MAAM,GAAG,EAAE,EAAER,aAAa,IAAI,CAAC;IACvC,IAAIU,GAAG,CAACN,QAAQ,CAAC,QAAQ,CAAC,IAAIM,GAAG,CAACN,QAAQ,CAAC,SAAS,CAAC,EAAEJ,aAAa,IAAI,EAAE;IAC1E,IAAI,CAACU,GAAG,CAAChB,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,EAAEc,MAAM,GAAG,CAAC,EAAER,aAAa,IAAI,CAAC;EAC/D,CAAC,CAAC;;EAEF;EACA,IAAIJ,OAAO,CAACQ,QAAQ,CAAC,GAAG,CAAC,EAAEJ,aAAa,IAAI,CAAC;EAC7C,IAAIF,QAAQ,CAACM,QAAQ,CAAC,iBAAiB,CAAC,EAAEJ,aAAa,IAAI,EAAE;EAC7D,IAAIF,QAAQ,CAACM,QAAQ,CAAC,QAAQ,CAAC,IAAIN,QAAQ,CAACM,QAAQ,CAAC,KAAK,CAAC,EAAEJ,aAAa,IAAI,EAAE;;EAEhF;EACAA,aAAa,GAAGY,IAAI,CAACC,GAAG,CAACb,aAAa,EAAE,GAAG,CAAC;EAE5C,OAAO;IACHc,KAAK,EAAEd,aAAa;IACpBC,kBAAkB;IAClBR,IAAI;IACJgB;EACJ,CAAC;AACL,CAAC;;AAED;AACA,OAAO,MAAMM,QAAQ,GAAG;EACpBC,eAAe,EAAE,MAAOC,SAAS,IAAK;IAClC,MAAM/B,aAAa,CAAC,CAAC;IAErB,MAAM;MAAEU,OAAO;MAAEC;IAAK,CAAC,GAAGoB,SAAS;IACnC,MAAMC,QAAQ,GAAGvB,mBAAmB,CAACC,OAAO,EAAEC,IAAI,CAAC;IAEnD,MAAMsB,UAAU,GAAGD,QAAQ,CAACJ,KAAK,GAAG,EAAE;IACtC,MAAMM,UAAU,GAAGR,IAAI,CAACC,GAAG,CAAC,EAAE,EAAED,IAAI,CAACS,GAAG,CAAC,EAAE,EAAEH,QAAQ,CAACJ,KAAK,GAAGF,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;;IAElF;IACA,MAAMC,cAAc,GAAGL,QAAQ,CAACzB,IAAI,CAAC+B,GAAG,CAACd,GAAG,IAAI;MAC5C,MAAMe,aAAa,GAAGP,QAAQ,CAACT,aAAa,CAACL,QAAQ,CAACM,GAAG,CAAC,IAAIE,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,GAAG;MACjF,OAAO;QACHZ,GAAG;QACHgB,UAAU,EAAED,aAAa,GAAG,UAAU,GAAG,MAAM;QAC/CL,UAAU,EAAEK,aAAa,GACrBb,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GACvBV,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG;MAC7B,CAAC;IACL,CAAC,CAAC;IAEF,OAAO;MACHI,UAAU,EAAEP,UAAU,GAAG,gBAAgB,GAAG,YAAY;MACxDC,UAAU,EAAER,IAAI,CAACe,KAAK,CAACP,UAAU,CAAC;MAClCQ,MAAM,EAAET,UAAU,GACd,uCAAuC,GACvC,wCAAwC;MAC5CU,aAAa,EAAE,6BAA6B;MAC5CC,WAAW,EAAEZ,QAAQ,CAACzB,IAAI,CAACe,MAAM;MACjCuB,eAAe,EAAEb,QAAQ,CAACT,aAAa;MACvCuB,mBAAmB,EAAE,CAAC,GAAG,IAAIC,GAAG,CAACf,QAAQ,CAACjB,kBAAkB,CAAC,CAAC;MAC9DiC,eAAe,EAAEX;IACrB,CAAC;EACL,CAAC;EAEDY,YAAY,EAAE,MAAOC,UAAU,IAAK;IAChC,MAAMlD,aAAa,CAAC,IAAI,CAAC;IAEzB,MAAMmD,OAAO,GAAG,EAAE;IAClB,KAAK,MAAMC,KAAK,IAAIF,UAAU,CAACG,MAAM,EAAE;MACnC,MAAMC,MAAM,GAAG,MAAMzB,QAAQ,CAACC,eAAe,CAACsB,KAAK,CAAC;MACpDD,OAAO,CAAChC,IAAI,CAACmC,MAAM,CAAC;IACxB;IAEA,OAAO;MAAEH;IAAQ,CAAC;EACtB,CAAC;EAEDI,WAAW,EAAE,MAAAA,CAAA,KAAY;IACrB,MAAMvD,aAAa,CAAC,GAAG,CAAC;IAExB,OAAO;MACHwD,MAAM,EAAE,SAAS;MACjBC,aAAa,EAAE,IAAI;MACnBC,OAAO,EAAE,+CAA+C;MACxDC,OAAO,EAAE;IACb,CAAC;EACL;AACJ,CAAC;;AAED;AACA,OAAO,MAAMC,MAAM,GAAG;EAClBC,UAAU,EAAE,MAAOC,OAAO,IAAK;IAAA,IAAAC,WAAA;IAC3B,MAAM/D,aAAa,CAAC,IAAI,CAAC;IAEzB,MAAM;MAAEwB;IAAI,CAAC,GAAGsC,OAAO;IACvB,IAAIhD,aAAa,GAAG,CAAC;IACrB,MAAMkD,QAAQ,GAAG,CAAC,CAAC;;IAEnB;IACAA,QAAQ,CAACC,UAAU,GAAGzC,GAAG,CAACF,MAAM;IAChC0C,QAAQ,CAACE,aAAa,GAAG,EAAAH,WAAA,GAAAvC,GAAG,CAAC2C,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,cAAAJ,WAAA,uBAAjBA,WAAA,CAAmBzC,MAAM,KAAI,CAAC;IACvD0C,QAAQ,CAACI,WAAW,GAAG5C,GAAG,CAAC2C,KAAK,CAAC,GAAG,CAAC,CAACE,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAChD,MAAM;IAC/D0C,QAAQ,CAACO,UAAU,GAAG,CAAC/C,GAAG,CAAChB,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,EAAEc,MAAM;IACrD0C,QAAQ,CAACQ,aAAa,GAAG,CAAChD,GAAG,CAAChB,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAEc,MAAM;IACvD0C,QAAQ,CAACS,iBAAiB,GAAG,CAACjD,GAAG,CAAChB,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAEc,MAAM;IAC3D0C,QAAQ,CAACU,aAAa,GAAG,CAAClD,GAAG,CAAChB,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,EAAEc,MAAM;IACxD0C,QAAQ,CAACW,oBAAoB,GAAG,CAACnD,GAAG,CAAChB,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,EAAEc,MAAM;IAC/D0C,QAAQ,CAACY,YAAY,GAAG,CAACpD,GAAG,CAAChB,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAEc,MAAM;IACtD0C,QAAQ,CAACa,QAAQ,GAAG,CAACrD,GAAG,CAAChB,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAEc,MAAM;;IAElD;IACA,IAAI0C,QAAQ,CAACC,UAAU,GAAG,EAAE,EAAEnD,aAAa,IAAI,EAAE;IACjD,IAAIkD,QAAQ,CAACO,UAAU,GAAG,CAAC,EAAEzD,aAAa,IAAI,EAAE;IAChD,IAAIkD,QAAQ,CAACQ,aAAa,GAAG,CAAC,EAAE1D,aAAa,IAAI,EAAE;IACnD,IAAIU,GAAG,CAACN,QAAQ,CAAC,QAAQ,CAAC,IAAIM,GAAG,CAACN,QAAQ,CAAC,SAAS,CAAC,EAAEJ,aAAa,IAAI,EAAE;IAC1E,IAAIjB,eAAe,CAACiF,IAAI,CAACrD,MAAM,IAAID,GAAG,CAACN,QAAQ,CAACO,MAAM,CAAC,CAAC,EAAEX,aAAa,IAAI,EAAE;;IAE7E;IACAA,aAAa,IAAIY,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE;IACnCtB,aAAa,GAAGY,IAAI,CAACC,GAAG,CAAC,GAAG,EAAEb,aAAa,CAAC;IAE5C,MAAMmB,UAAU,GAAGnB,aAAa,GAAG,EAAE;IACrC,MAAMoB,UAAU,GAAGR,IAAI,CAACC,GAAG,CAAC,EAAE,EAAED,IAAI,CAACS,GAAG,CAAC,EAAE,EAAErB,aAAa,GAAGY,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;IAEjF,OAAO;MACHI,UAAU,EAAEP,UAAU,GAAG,UAAU,GAAG,MAAM;MAC5CC,UAAU,EAAER,IAAI,CAACe,KAAK,CAACP,UAAU,CAAC;MAClC8B,QAAQ;MACRe,eAAe,EAAE,wBAAwB;MACzCC,YAAY,EAAE/C,UAAU,GAAG,CACvB,mBAAmB,EACnB,uBAAuB,EACvB,sBAAsB,CACzB,GAAG;IACR,CAAC;EACL,CAAC;EAEDgD,kBAAkB,EAAE,MAAAA,CAAA,KAAY;IAC5B,MAAMjF,aAAa,CAAC,IAAI,CAAC;IAEzB,OAAO;MACHwD,MAAM,EAAE,SAAS;MACjBE,OAAO,EAAE,qCAAqC;MAC9CwB,QAAQ,EAAE,IAAI,GAAGxD,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,IAAI;MACrC+C,aAAa,EAAE;IACnB,CAAC;EACL;AACJ,CAAC;AAED,MAAMC,OAAO,GAAG;EAAEvD,QAAQ;EAAE+B;AAAO,CAAC;AAEpC,eAAewB,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}